<?php
/**
 * TweetsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Twitter API v2
 *
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.45
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * TweetsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TweetsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addOrDeleteRules
     *
     * Add/Delete rules
     *
     * @param  \OpenAPI\Client\Model\AddOrDeleteRulesRequest $add_or_delete_rules_request add_or_delete_rules_request (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AddOrDeleteRulesResponse|\OpenAPI\Client\Model\Error
     */
    public function addOrDeleteRules($add_or_delete_rules_request, $dry_run = null)
    {
        list($response) = $this->addOrDeleteRulesWithHttpInfo($add_or_delete_rules_request, $dry_run);
        return $response;
    }

    /**
     * Operation addOrDeleteRulesWithHttpInfo
     *
     * Add/Delete rules
     *
     * @param  \OpenAPI\Client\Model\AddOrDeleteRulesRequest $add_or_delete_rules_request (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AddOrDeleteRulesResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function addOrDeleteRulesWithHttpInfo($add_or_delete_rules_request, $dry_run = null)
    {
        $request = $this->addOrDeleteRulesRequest($add_or_delete_rules_request, $dry_run);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\AddOrDeleteRulesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AddOrDeleteRulesResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AddOrDeleteRulesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\AddOrDeleteRulesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AddOrDeleteRulesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addOrDeleteRulesAsync
     *
     * Add/Delete rules
     *
     * @param  \OpenAPI\Client\Model\AddOrDeleteRulesRequest $add_or_delete_rules_request (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addOrDeleteRulesAsync($add_or_delete_rules_request, $dry_run = null)
    {
        return $this->addOrDeleteRulesAsyncWithHttpInfo($add_or_delete_rules_request, $dry_run)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addOrDeleteRulesAsyncWithHttpInfo
     *
     * Add/Delete rules
     *
     * @param  \OpenAPI\Client\Model\AddOrDeleteRulesRequest $add_or_delete_rules_request (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addOrDeleteRulesAsyncWithHttpInfo($add_or_delete_rules_request, $dry_run = null)
    {
        $returnType = '\OpenAPI\Client\Model\AddOrDeleteRulesResponse';
        $request = $this->addOrDeleteRulesRequest($add_or_delete_rules_request, $dry_run);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addOrDeleteRules'
     *
     * @param  \OpenAPI\Client\Model\AddOrDeleteRulesRequest $add_or_delete_rules_request (required)
     * @param  bool $dry_run Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addOrDeleteRulesRequest($add_or_delete_rules_request, $dry_run = null)
    {
        // verify the required parameter 'add_or_delete_rules_request' is set
        if ($add_or_delete_rules_request === null || (is_array($add_or_delete_rules_request) && count($add_or_delete_rules_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_or_delete_rules_request when calling addOrDeleteRules'
            );
        }

        $resourcePath = '/2/tweets/search/stream/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dry_run,
            'dry_run', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($add_or_delete_rules_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($add_or_delete_rules_request));
            } else {
                $httpBody = $add_or_delete_rules_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTweet
     *
     * Creation of a Tweet
     *
     * @param  \OpenAPI\Client\Model\TweetCreateRequest $tweet_create_request tweet_create_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TweetCreateResponse|\OpenAPI\Client\Model\Error
     */
    public function createTweet($tweet_create_request)
    {
        list($response) = $this->createTweetWithHttpInfo($tweet_create_request);
        return $response;
    }

    /**
     * Operation createTweetWithHttpInfo
     *
     * Creation of a Tweet
     *
     * @param  \OpenAPI\Client\Model\TweetCreateRequest $tweet_create_request (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TweetCreateResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTweetWithHttpInfo($tweet_create_request)
    {
        $request = $this->createTweetRequest($tweet_create_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\TweetCreateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TweetCreateResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TweetCreateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TweetCreateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TweetCreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTweetAsync
     *
     * Creation of a Tweet
     *
     * @param  \OpenAPI\Client\Model\TweetCreateRequest $tweet_create_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTweetAsync($tweet_create_request)
    {
        return $this->createTweetAsyncWithHttpInfo($tweet_create_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTweetAsyncWithHttpInfo
     *
     * Creation of a Tweet
     *
     * @param  \OpenAPI\Client\Model\TweetCreateRequest $tweet_create_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTweetAsyncWithHttpInfo($tweet_create_request)
    {
        $returnType = '\OpenAPI\Client\Model\TweetCreateResponse';
        $request = $this->createTweetRequest($tweet_create_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTweet'
     *
     * @param  \OpenAPI\Client\Model\TweetCreateRequest $tweet_create_request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTweetRequest($tweet_create_request)
    {
        // verify the required parameter 'tweet_create_request' is set
        if ($tweet_create_request === null || (is_array($tweet_create_request) && count($tweet_create_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_create_request when calling createTweet'
            );
        }

        $resourcePath = '/2/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($tweet_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($tweet_create_request));
            } else {
                $httpBody = $tweet_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTweetById
     *
     * Tweet delete by Tweet ID
     *
     * @param  string $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TweetDeleteResponse|\OpenAPI\Client\Model\Error
     */
    public function deleteTweetById($id)
    {
        list($response) = $this->deleteTweetByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteTweetByIdWithHttpInfo
     *
     * Tweet delete by Tweet ID
     *
     * @param  string $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TweetDeleteResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTweetByIdWithHttpInfo($id)
    {
        $request = $this->deleteTweetByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TweetDeleteResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TweetDeleteResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TweetDeleteResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TweetDeleteResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TweetDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTweetByIdAsync
     *
     * Tweet delete by Tweet ID
     *
     * @param  string $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTweetByIdAsync($id)
    {
        return $this->deleteTweetByIdAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTweetByIdAsyncWithHttpInfo
     *
     * Tweet delete by Tweet ID
     *
     * @param  string $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTweetByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\OpenAPI\Client\Model\TweetDeleteResponse';
        $request = $this->deleteTweetByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTweetById'
     *
     * @param  string $id The ID of the Tweet to be deleted. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTweetByIdRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteTweetById'
            );
        }
        if (!preg_match("/^[0-9]{1,19}$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.deleteTweetById, must conform to the pattern /^[0-9]{1,19}$/.");
        }


        $resourcePath = '/2/tweets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findTweetById
     *
     * Tweet lookup by Tweet ID
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2TweetsIdResponse|\OpenAPI\Client\Model\Error
     */
    public function findTweetById($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->findTweetByIdWithHttpInfo($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation findTweetByIdWithHttpInfo
     *
     * Tweet lookup by Tweet ID
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2TweetsIdResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function findTweetByIdWithHttpInfo($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->findTweetByIdRequest($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2TweetsIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2TweetsIdResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2TweetsIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2TweetsIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2TweetsIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findTweetByIdAsync
     *
     * Tweet lookup by Tweet ID
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetByIdAsync($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->findTweetByIdAsyncWithHttpInfo($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findTweetByIdAsyncWithHttpInfo
     *
     * Tweet lookup by Tweet ID
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetByIdAsyncWithHttpInfo($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2TweetsIdResponse';
        $request = $this->findTweetByIdRequest($id, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findTweetById'
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findTweetByIdRequest($id, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling findTweetById'
            );
        }
        if (!preg_match("/^[0-9]{1,19}$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.findTweetById, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.findTweetById, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.findTweetById, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.findTweetById, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.findTweetById, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.findTweetById, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.findTweetById, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findTweetsById
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  string[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2TweetsResponse|\OpenAPI\Client\Model\Error
     */
    public function findTweetsById($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->findTweetsByIdWithHttpInfo($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation findTweetsByIdWithHttpInfo
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  string[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2TweetsResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function findTweetsByIdWithHttpInfo($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->findTweetsByIdRequest($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2TweetsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2TweetsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2TweetsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2TweetsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2TweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findTweetsByIdAsync
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  string[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsByIdAsync($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->findTweetsByIdAsyncWithHttpInfo($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findTweetsByIdAsyncWithHttpInfo
     *
     * Tweet lookup by Tweet IDs
     *
     * @param  string[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsByIdAsyncWithHttpInfo($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2TweetsResponse';
        $request = $this->findTweetsByIdRequest($ids, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findTweetsById'
     *
     * @param  string[] $ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request. (required)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findTweetsByIdRequest($ids, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling findTweetsById'
            );
        }
        if (count($ids) > 100) {
            throw new \InvalidArgumentException('invalid value for "$ids" when calling TweetsApi.findTweetsById, number of items must be less than or equal to 100.');
        }
        if (count($ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$ids" when calling TweetsApi.findTweetsById, number of items must be greater than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.findTweetsById, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.findTweetsById, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.findTweetsById, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.findTweetsById, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.findTweetsById, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.findTweetsById, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findTweetsThatQuoteATweet
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse|\OpenAPI\Client\Model\Error
     */
    public function findTweetsThatQuoteATweet($id, $max_results = 10, $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->findTweetsThatQuoteATweetWithHttpInfo($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation findTweetsThatQuoteATweetWithHttpInfo
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function findTweetsThatQuoteATweetWithHttpInfo($id, $max_results = 10, $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->findTweetsThatQuoteATweetRequest($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findTweetsThatQuoteATweetAsync
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsThatQuoteATweetAsync($id, $max_results = 10, $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->findTweetsThatQuoteATweetAsyncWithHttpInfo($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findTweetsThatQuoteATweetAsyncWithHttpInfo
     *
     * Retrieve Tweets that quote a Tweet.
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findTweetsThatQuoteATweetAsyncWithHttpInfo($id, $max_results = 10, $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2TweetsIdQuoteTweetsResponse';
        $request = $this->findTweetsThatQuoteATweetRequest($id, $max_results, $pagination_token, $exclude, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findTweetsThatQuoteATweet'
     *
     * @param  string $id A single Tweet ID. (required)
     * @param  int $max_results The maximum number of results to be returned. (optional, default to 10)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function findTweetsThatQuoteATweetRequest($id, $max_results = 10, $pagination_token = null, $exclude = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling findTweetsThatQuoteATweet'
            );
        }
        if (!preg_match("/^[0-9]{1,19}$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.findTweetsThatQuoteATweet, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.findTweetsThatQuoteATweet, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 10) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.findTweetsThatQuoteATweet, must be bigger than or equal to 10.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.findTweetsThatQuoteATweet, must be bigger than or equal to 1.');
        }

        if ($exclude !== null && count($exclude) < 1) {
            throw new \InvalidArgumentException('invalid value for "$exclude" when calling TweetsApi.findTweetsThatQuoteATweet, number of items must be greater than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.findTweetsThatQuoteATweet, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.findTweetsThatQuoteATweet, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.findTweetsThatQuoteATweet, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.findTweetsThatQuoteATweet, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.findTweetsThatQuoteATweet, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.findTweetsThatQuoteATweet, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/{id}/quote_tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRules
     *
     * Rules lookup
     *
     * @param  string[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#39;next_token&#39; returned in a request to paginate through results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RulesLookupResponse|\OpenAPI\Client\Model\Error
     */
    public function getRules($ids = null, $max_results = 1000, $pagination_token = null)
    {
        list($response) = $this->getRulesWithHttpInfo($ids, $max_results, $pagination_token);
        return $response;
    }

    /**
     * Operation getRulesWithHttpInfo
     *
     * Rules lookup
     *
     * @param  string[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#39;next_token&#39; returned in a request to paginate through results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RulesLookupResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRulesWithHttpInfo($ids = null, $max_results = 1000, $pagination_token = null)
    {
        $request = $this->getRulesRequest($ids, $max_results, $pagination_token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\RulesLookupResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\RulesLookupResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\RulesLookupResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\RulesLookupResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RulesLookupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRulesAsync
     *
     * Rules lookup
     *
     * @param  string[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#39;next_token&#39; returned in a request to paginate through results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesAsync($ids = null, $max_results = 1000, $pagination_token = null)
    {
        return $this->getRulesAsyncWithHttpInfo($ids, $max_results, $pagination_token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRulesAsyncWithHttpInfo
     *
     * Rules lookup
     *
     * @param  string[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#39;next_token&#39; returned in a request to paginate through results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRulesAsyncWithHttpInfo($ids = null, $max_results = 1000, $pagination_token = null)
    {
        $returnType = '\OpenAPI\Client\Model\RulesLookupResponse';
        $request = $this->getRulesRequest($ids, $max_results, $pagination_token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRules'
     *
     * @param  string[] $ids A comma-separated list of Rule IDs. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 1000)
     * @param  string $pagination_token This value is populated by passing the &#39;next_token&#39; returned in a request to paginate through results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRulesRequest($ids = null, $max_results = 1000, $pagination_token = null)
    {
        if ($max_results !== null && $max_results > 1000) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.getRules, must be smaller than or equal to 1000.');
        }
        if ($max_results !== null && $max_results < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.getRules, must be bigger than or equal to 1.');
        }

        if ($pagination_token !== null && strlen($pagination_token) > 16) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.getRules, must be smaller than or equal to 16.');
        }
        if ($pagination_token !== null && strlen($pagination_token) < 16) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.getRules, must be bigger than or equal to 16.');
        }


        $resourcePath = '/2/tweets/search/stream/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideReplyById
     *
     * Hide replies
     *
     * @param  string $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \OpenAPI\Client\Model\TweetHideRequest $tweet_hide_request tweet_hide_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TweetHideResponse|\OpenAPI\Client\Model\Error
     */
    public function hideReplyById($tweet_id, $tweet_hide_request = null)
    {
        list($response) = $this->hideReplyByIdWithHttpInfo($tweet_id, $tweet_hide_request);
        return $response;
    }

    /**
     * Operation hideReplyByIdWithHttpInfo
     *
     * Hide replies
     *
     * @param  string $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \OpenAPI\Client\Model\TweetHideRequest $tweet_hide_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TweetHideResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideReplyByIdWithHttpInfo($tweet_id, $tweet_hide_request = null)
    {
        $request = $this->hideReplyByIdRequest($tweet_id, $tweet_hide_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\TweetHideResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\TweetHideResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\TweetHideResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\TweetHideResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TweetHideResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation hideReplyByIdAsync
     *
     * Hide replies
     *
     * @param  string $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \OpenAPI\Client\Model\TweetHideRequest $tweet_hide_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideReplyByIdAsync($tweet_id, $tweet_hide_request = null)
    {
        return $this->hideReplyByIdAsyncWithHttpInfo($tweet_id, $tweet_hide_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideReplyByIdAsyncWithHttpInfo
     *
     * Hide replies
     *
     * @param  string $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \OpenAPI\Client\Model\TweetHideRequest $tweet_hide_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideReplyByIdAsyncWithHttpInfo($tweet_id, $tweet_hide_request = null)
    {
        $returnType = '\OpenAPI\Client\Model\TweetHideResponse';
        $request = $this->hideReplyByIdRequest($tweet_id, $tweet_hide_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideReplyById'
     *
     * @param  string $tweet_id The ID of the reply that you want to hide or unhide. (required)
     * @param  \OpenAPI\Client\Model\TweetHideRequest $tweet_hide_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function hideReplyByIdRequest($tweet_id, $tweet_hide_request = null)
    {
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling hideReplyById'
            );
        }
        if (!preg_match("/^[0-9]{1,19}$/", $tweet_id)) {
            throw new \InvalidArgumentException("invalid value for \"tweet_id\" when calling TweetsApi.hideReplyById, must conform to the pattern /^[0-9]{1,19}$/.");
        }


        $resourcePath = '/2/tweets/{tweet_id}/hidden';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($tweet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tweet_id' . '}',
                ObjectSerializer::toPathValue($tweet_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($tweet_hide_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($tweet_hide_request));
            } else {
                $httpBody = $tweet_hide_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listsIdTweets
     *
     * List Tweets timeline by List ID.
     *
     * @param  string $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2ListsIdTweetsResponse|\OpenAPI\Client\Model\Error
     */
    public function listsIdTweets($id, $max_results = 100, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->listsIdTweetsWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation listsIdTweetsWithHttpInfo
     *
     * List Tweets timeline by List ID.
     *
     * @param  string $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2ListsIdTweetsResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function listsIdTweetsWithHttpInfo($id, $max_results = 100, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->listsIdTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2ListsIdTweetsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2ListsIdTweetsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2ListsIdTweetsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2ListsIdTweetsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2ListsIdTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listsIdTweetsAsync
     *
     * List Tweets timeline by List ID.
     *
     * @param  string $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listsIdTweetsAsync($id, $max_results = 100, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->listsIdTweetsAsyncWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listsIdTweetsAsyncWithHttpInfo
     *
     * List Tweets timeline by List ID.
     *
     * @param  string $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listsIdTweetsAsyncWithHttpInfo($id, $max_results = 100, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2ListsIdTweetsResponse';
        $request = $this->listsIdTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listsIdTweets'
     *
     * @param  string $id The ID of the List. (required)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listsIdTweetsRequest($id, $max_results = 100, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling listsIdTweets'
            );
        }
        if (!preg_match("/^[0-9]{1,19}$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.listsIdTweets, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.listsIdTweets, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.listsIdTweets, must be bigger than or equal to 1.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.listsIdTweets, must be bigger than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.listsIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.listsIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.listsIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.listsIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.listsIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.listsIdTweets, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/lists/{id}/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sampleStream
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StreamingTweetResponse|\OpenAPI\Client\Model\Error
     */
    public function sampleStream($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->sampleStreamWithHttpInfo($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation sampleStreamWithHttpInfo
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StreamingTweetResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function sampleStreamWithHttpInfo($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->sampleStreamRequest($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StreamingTweetResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\StreamingTweetResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StreamingTweetResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\StreamingTweetResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StreamingTweetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sampleStreamAsync
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sampleStreamAsync($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->sampleStreamAsyncWithHttpInfo($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sampleStreamAsyncWithHttpInfo
     *
     * Sample stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sampleStreamAsyncWithHttpInfo($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\StreamingTweetResponse';
        $request = $this->sampleStreamRequest($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sampleStream'
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sampleStreamRequest($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        if ($backfill_minutes !== null && $backfill_minutes > 5) {
            throw new \InvalidArgumentException('invalid value for "$backfill_minutes" when calling TweetsApi.sampleStream, must be smaller than or equal to 5.');
        }
        if ($backfill_minutes !== null && $backfill_minutes < 0) {
            throw new \InvalidArgumentException('invalid value for "$backfill_minutes" when calling TweetsApi.sampleStream, must be bigger than or equal to 0.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.sampleStream, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.sampleStream, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.sampleStream, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.sampleStream, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.sampleStream, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.sampleStream, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/sample/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $backfill_minutes,
            'backfill_minutes', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchStream
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FilteredStreamingTweetResponse|\OpenAPI\Client\Model\Error
     */
    public function searchStream($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->searchStreamWithHttpInfo($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation searchStreamWithHttpInfo
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FilteredStreamingTweetResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchStreamWithHttpInfo($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->searchStreamRequest($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FilteredStreamingTweetResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FilteredStreamingTweetResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FilteredStreamingTweetResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\FilteredStreamingTweetResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FilteredStreamingTweetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchStreamAsync
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStreamAsync($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->searchStreamAsyncWithHttpInfo($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchStreamAsyncWithHttpInfo
     *
     * Filtered stream
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStreamAsyncWithHttpInfo($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\FilteredStreamingTweetResponse';
        $request = $this->searchStreamRequest($backfill_minutes, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchStream'
     *
     * @param  int $backfill_minutes The number of minutes of backfill requested. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchStreamRequest($backfill_minutes = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        if ($backfill_minutes !== null && $backfill_minutes > 5) {
            throw new \InvalidArgumentException('invalid value for "$backfill_minutes" when calling TweetsApi.searchStream, must be smaller than or equal to 5.');
        }
        if ($backfill_minutes !== null && $backfill_minutes < 0) {
            throw new \InvalidArgumentException('invalid value for "$backfill_minutes" when calling TweetsApi.searchStream, must be bigger than or equal to 0.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.searchStream, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.searchStream, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.searchStream, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.searchStream, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.searchStream, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.searchStream, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/search/stream';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $backfill_minutes,
            'backfill_minutes', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation spaceBuyers
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2SpacesIdBuyersResponse|\OpenAPI\Client\Model\Error
     */
    public function spaceBuyers($id, $pagination_token = null, $max_results = 100, $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        list($response) = $this->spaceBuyersWithHttpInfo($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields);
        return $response;
    }

    /**
     * Operation spaceBuyersWithHttpInfo
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2SpacesIdBuyersResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function spaceBuyersWithHttpInfo($id, $pagination_token = null, $max_results = 100, $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        $request = $this->spaceBuyersRequest($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2SpacesIdBuyersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2SpacesIdBuyersResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2SpacesIdBuyersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2SpacesIdBuyersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2SpacesIdBuyersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation spaceBuyersAsync
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceBuyersAsync($id, $pagination_token = null, $max_results = 100, $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        return $this->spaceBuyersAsyncWithHttpInfo($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation spaceBuyersAsyncWithHttpInfo
     *
     * Retrieve the list of Users who purchased a ticket to the given space
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceBuyersAsyncWithHttpInfo($id, $pagination_token = null, $max_results = 100, $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2SpacesIdBuyersResponse';
        $request = $this->spaceBuyersRequest($id, $pagination_token, $max_results, $user_fields, $expansions, $tweet_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'spaceBuyers'
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  string $pagination_token This parameter is used to get a specified &#39;page&#39; of results. (optional)
     * @param  int $max_results The maximum number of results. (optional, default to 100)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function spaceBuyersRequest($id, $pagination_token = null, $max_results = 100, $user_fields = null, $expansions = null, $tweet_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling spaceBuyers'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9]{1,13}$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.spaceBuyers, must conform to the pattern /^[a-zA-Z0-9]{1,13}$/.");
        }

        if ($pagination_token !== null && strlen($pagination_token) < 16) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.spaceBuyers, must be bigger than or equal to 16.');
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.spaceBuyers, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.spaceBuyers, must be bigger than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.spaceBuyers, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.spaceBuyers, number of items must be greater than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.spaceBuyers, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/spaces/{id}/buyers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation spaceTweets
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2SpacesIdTweetsResponse|\OpenAPI\Client\Model\Error
     */
    public function spaceTweets($id, $max_results = 100, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->spaceTweetsWithHttpInfo($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation spaceTweetsWithHttpInfo
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2SpacesIdTweetsResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function spaceTweetsWithHttpInfo($id, $max_results = 100, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->spaceTweetsRequest($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2SpacesIdTweetsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2SpacesIdTweetsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2SpacesIdTweetsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2SpacesIdTweetsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2SpacesIdTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation spaceTweetsAsync
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceTweetsAsync($id, $max_results = 100, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->spaceTweetsAsyncWithHttpInfo($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation spaceTweetsAsyncWithHttpInfo
     *
     * Retrieve Tweets from a Space.
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function spaceTweetsAsyncWithHttpInfo($id, $max_results = 100, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2SpacesIdTweetsResponse';
        $request = $this->spaceTweetsRequest($id, $max_results, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'spaceTweets'
     *
     * @param  string $id The ID of the Space to be retrieved. (required)
     * @param  int $max_results The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100. (optional, default to 100)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function spaceTweetsRequest($id, $max_results = 100, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling spaceTweets'
            );
        }
        if (!preg_match("/^[a-zA-Z0-9]{1,13}$/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.spaceTweets, must conform to the pattern /^[a-zA-Z0-9]{1,13}$/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.spaceTweets, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.spaceTweets, must be bigger than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.spaceTweets, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.spaceTweets, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.spaceTweets, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.spaceTweets, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.spaceTweets, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.spaceTweets, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/spaces/{id}/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetCountsFullArchiveSearch
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2TweetsCountsAllResponse|\OpenAPI\Client\Model\Error
     */
    public function tweetCountsFullArchiveSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        list($response) = $this->tweetCountsFullArchiveSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);
        return $response;
    }

    /**
     * Operation tweetCountsFullArchiveSearchWithHttpInfo
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2TweetsCountsAllResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetCountsFullArchiveSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $request = $this->tweetCountsFullArchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2TweetsCountsAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2TweetsCountsAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2TweetsCountsAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2TweetsCountsAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2TweetsCountsAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetCountsFullArchiveSearchAsync
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsFullArchiveSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        return $this->tweetCountsFullArchiveSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetCountsFullArchiveSearchAsyncWithHttpInfo
     *
     * Full archive search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsFullArchiveSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2TweetsCountsAllResponse';
        $request = $this->tweetCountsFullArchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetCountsFullArchiveSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tweetCountsFullArchiveSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetCountsFullArchiveSearch'
            );
        }
        if (strlen($query) > 4096) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetCountsFullArchiveSearch, must be smaller than or equal to 4096.');
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetCountsFullArchiveSearch, must be bigger than or equal to 1.');
        }

        if ($since_id !== null && !preg_match("/^[0-9]{1,19}$/", $since_id)) {
            throw new \InvalidArgumentException("invalid value for \"since_id\" when calling TweetsApi.tweetCountsFullArchiveSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($until_id !== null && !preg_match("/^[0-9]{1,19}$/", $until_id)) {
            throw new \InvalidArgumentException("invalid value for \"until_id\" when calling TweetsApi.tweetCountsFullArchiveSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($next_token !== null && strlen($next_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$next_token" when calling TweetsApi.tweetCountsFullArchiveSearch, must be bigger than or equal to 1.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.tweetCountsFullArchiveSearch, must be bigger than or equal to 1.');
        }

        if ($search_count_fields !== null && count($search_count_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$search_count_fields" when calling TweetsApi.tweetCountsFullArchiveSearch, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/counts/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'start_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'end_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $until_id,
            'until_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_token,
            'next_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $granularity,
            'granularity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_count_fields,
            'search_count.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetCountsRecentSearch
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2TweetsCountsRecentResponse|\OpenAPI\Client\Model\Error
     */
    public function tweetCountsRecentSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        list($response) = $this->tweetCountsRecentSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);
        return $response;
    }

    /**
     * Operation tweetCountsRecentSearchWithHttpInfo
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2TweetsCountsRecentResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetCountsRecentSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $request = $this->tweetCountsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2TweetsCountsRecentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2TweetsCountsRecentResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2TweetsCountsRecentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2TweetsCountsRecentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2TweetsCountsRecentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetCountsRecentSearchAsync
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsRecentSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        return $this->tweetCountsRecentSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetCountsRecentSearchAsyncWithHttpInfo
     *
     * Recent search counts
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetCountsRecentSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2TweetsCountsRecentResponse';
        $request = $this->tweetCountsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $next_token, $pagination_token, $granularity, $search_count_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetCountsRecentSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $granularity The granularity for the search counts results. (optional, default to 'hour')
     * @param  string[] $search_count_fields A comma separated list of SearchCount fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tweetCountsRecentSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $next_token = null, $pagination_token = null, $granularity = 'hour', $search_count_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetCountsRecentSearch'
            );
        }
        if (strlen($query) > 4096) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetCountsRecentSearch, must be smaller than or equal to 4096.');
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetCountsRecentSearch, must be bigger than or equal to 1.');
        }

        if ($since_id !== null && !preg_match("/^[0-9]{1,19}$/", $since_id)) {
            throw new \InvalidArgumentException("invalid value for \"since_id\" when calling TweetsApi.tweetCountsRecentSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($until_id !== null && !preg_match("/^[0-9]{1,19}$/", $until_id)) {
            throw new \InvalidArgumentException("invalid value for \"until_id\" when calling TweetsApi.tweetCountsRecentSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($next_token !== null && strlen($next_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$next_token" when calling TweetsApi.tweetCountsRecentSearch, must be bigger than or equal to 1.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.tweetCountsRecentSearch, must be bigger than or equal to 1.');
        }

        if ($search_count_fields !== null && count($search_count_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$search_count_fields" when calling TweetsApi.tweetCountsRecentSearch, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/counts/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'start_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'end_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $until_id,
            'until_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_token,
            'next_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $granularity,
            'granularity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_count_fields,
            'search_count.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetsFullarchiveSearch
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2TweetsSearchAllResponse|\OpenAPI\Client\Model\Error
     */
    public function tweetsFullarchiveSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->tweetsFullarchiveSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation tweetsFullarchiveSearchWithHttpInfo
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2TweetsSearchAllResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetsFullarchiveSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->tweetsFullarchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2TweetsSearchAllResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2TweetsSearchAllResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2TweetsSearchAllResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2TweetsSearchAllResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2TweetsSearchAllResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetsFullarchiveSearchAsync
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsFullarchiveSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->tweetsFullarchiveSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetsFullarchiveSearchAsyncWithHttpInfo
     *
     * Full-archive search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsFullarchiveSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2TweetsSearchAllResponse';
        $request = $this->tweetsFullarchiveSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetsFullarchiveSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tweetsFullarchiveSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetsFullarchiveSearch'
            );
        }
        if (strlen($query) > 4096) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetsFullarchiveSearch, must be smaller than or equal to 4096.');
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetsFullarchiveSearch, must be bigger than or equal to 1.');
        }

        if ($since_id !== null && !preg_match("/^[0-9]{1,19}$/", $since_id)) {
            throw new \InvalidArgumentException("invalid value for \"since_id\" when calling TweetsApi.tweetsFullarchiveSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($until_id !== null && !preg_match("/^[0-9]{1,19}$/", $until_id)) {
            throw new \InvalidArgumentException("invalid value for \"until_id\" when calling TweetsApi.tweetsFullarchiveSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($max_results !== null && $max_results > 500) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.tweetsFullarchiveSearch, must be smaller than or equal to 500.');
        }
        if ($max_results !== null && $max_results < 10) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.tweetsFullarchiveSearch, must be bigger than or equal to 10.');
        }

        if ($next_token !== null && strlen($next_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$next_token" when calling TweetsApi.tweetsFullarchiveSearch, must be bigger than or equal to 1.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.tweetsFullarchiveSearch, must be bigger than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.tweetsFullarchiveSearch, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.tweetsFullarchiveSearch, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.tweetsFullarchiveSearch, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.tweetsFullarchiveSearch, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.tweetsFullarchiveSearch, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.tweetsFullarchiveSearch, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/search/all';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'start_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'end_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $until_id,
            'until_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_token,
            'next_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sort_order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tweetsRecentSearch
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2TweetsSearchRecentResponse|\OpenAPI\Client\Model\Error
     */
    public function tweetsRecentSearch($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->tweetsRecentSearchWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation tweetsRecentSearchWithHttpInfo
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2TweetsSearchRecentResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function tweetsRecentSearchWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->tweetsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2TweetsSearchRecentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2TweetsSearchRecentResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2TweetsSearchRecentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2TweetsSearchRecentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2TweetsSearchRecentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tweetsRecentSearchAsync
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsRecentSearchAsync($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->tweetsRecentSearchAsyncWithHttpInfo($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tweetsRecentSearchAsyncWithHttpInfo
     *
     * Recent search
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tweetsRecentSearchAsyncWithHttpInfo($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2TweetsSearchRecentResponse';
        $request = $this->tweetsRecentSearchRequest($query, $start_time, $end_time, $since_id, $until_id, $max_results, $next_token, $pagination_token, $sort_order, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tweetsRecentSearch'
     *
     * @param  string $query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length. (required)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute). (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute). (optional)
     * @param  string $since_id Returns results with a Tweet ID greater than (that is, more recent than) the specified ID. (optional)
     * @param  string $until_id Returns results with a Tweet ID less than (that is, older than) the specified ID. (optional)
     * @param  int $max_results The maximum number of search results to be returned by a request. (optional, default to 10)
     * @param  string $next_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified. (optional)
     * @param  string $sort_order This order in which to return results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tweetsRecentSearchRequest($query, $start_time = null, $end_time = null, $since_id = null, $until_id = null, $max_results = 10, $next_token = null, $pagination_token = null, $sort_order = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query when calling tweetsRecentSearch'
            );
        }
        if (strlen($query) > 4096) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetsRecentSearch, must be smaller than or equal to 4096.');
        }
        if (strlen($query) < 1) {
            throw new \InvalidArgumentException('invalid length for "$query" when calling TweetsApi.tweetsRecentSearch, must be bigger than or equal to 1.');
        }

        if ($since_id !== null && !preg_match("/^[0-9]{1,19}$/", $since_id)) {
            throw new \InvalidArgumentException("invalid value for \"since_id\" when calling TweetsApi.tweetsRecentSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($until_id !== null && !preg_match("/^[0-9]{1,19}$/", $until_id)) {
            throw new \InvalidArgumentException("invalid value for \"until_id\" when calling TweetsApi.tweetsRecentSearch, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.tweetsRecentSearch, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 10) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.tweetsRecentSearch, must be bigger than or equal to 10.');
        }

        if ($next_token !== null && strlen($next_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$next_token" when calling TweetsApi.tweetsRecentSearch, must be bigger than or equal to 1.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.tweetsRecentSearch, must be bigger than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.tweetsRecentSearch, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.tweetsRecentSearch, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.tweetsRecentSearch, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.tweetsRecentSearch, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.tweetsRecentSearch, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.tweetsRecentSearch, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/tweets/search/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'start_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'end_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $until_id,
            'until_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $next_token,
            'next_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sort_order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdLike
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersLikesCreateRequest $users_likes_create_request users_likes_create_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UsersLikesCreateResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdLike($id, $users_likes_create_request = null)
    {
        list($response) = $this->usersIdLikeWithHttpInfo($id, $users_likes_create_request);
        return $response;
    }

    /**
     * Operation usersIdLikeWithHttpInfo
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersLikesCreateRequest $users_likes_create_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UsersLikesCreateResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdLikeWithHttpInfo($id, $users_likes_create_request = null)
    {
        $request = $this->usersIdLikeRequest($id, $users_likes_create_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UsersLikesCreateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UsersLikesCreateResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UsersLikesCreateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\UsersLikesCreateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UsersLikesCreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdLikeAsync
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersLikesCreateRequest $users_likes_create_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikeAsync($id, $users_likes_create_request = null)
    {
        return $this->usersIdLikeAsyncWithHttpInfo($id, $users_likes_create_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdLikeAsyncWithHttpInfo
     *
     * Causes the User (in the path) to like the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersLikesCreateRequest $users_likes_create_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikeAsyncWithHttpInfo($id, $users_likes_create_request = null)
    {
        $returnType = '\OpenAPI\Client\Model\UsersLikesCreateResponse';
        $request = $this->usersIdLikeRequest($id, $users_likes_create_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdLike'
     *
     * @param  string $id The ID of the authenticated source User that is requesting to like the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersLikesCreateRequest $users_likes_create_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdLikeRequest($id, $users_likes_create_request = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdLike'
            );
        }

        $resourcePath = '/2/users/{id}/likes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($users_likes_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($users_likes_create_request));
            } else {
                $httpBody = $users_likes_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdLikedTweets
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdLikedTweets($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdLikedTweetsWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdLikedTweetsWithHttpInfo
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdLikedTweetsWithHttpInfo($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->usersIdLikedTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdLikedTweetsAsync
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikedTweetsAsync($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdLikedTweetsAsyncWithHttpInfo($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdLikedTweetsAsyncWithHttpInfo
     *
     * Returns Tweet objects liked by the provided User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdLikedTweetsAsyncWithHttpInfo($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2UsersIdLikedTweetsResponse';
        $request = $this->usersIdLikedTweetsRequest($id, $max_results, $pagination_token, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdLikedTweets'
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdLikedTweetsRequest($id, $max_results = null, $pagination_token = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdLikedTweets'
            );
        }
        if (!preg_match("/^[0-9]{1,19}\\z/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.usersIdLikedTweets, must conform to the pattern /^[0-9]{1,19}\\z/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdLikedTweets, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 5) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdLikedTweets, must be bigger than or equal to 5.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.usersIdLikedTweets, must be bigger than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.usersIdLikedTweets, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.usersIdLikedTweets, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.usersIdLikedTweets, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.usersIdLikedTweets, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.usersIdLikedTweets, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.usersIdLikedTweets, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/users/{id}/liked_tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdMentions
     *
     * User mention timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2UsersIdMentionsResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdMentions($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdMentionsWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdMentionsWithHttpInfo
     *
     * User mention timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2UsersIdMentionsResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdMentionsWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->usersIdMentionsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2UsersIdMentionsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2UsersIdMentionsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2UsersIdMentionsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2UsersIdMentionsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2UsersIdMentionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdMentionsAsync
     *
     * User mention timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdMentionsAsync($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdMentionsAsyncWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdMentionsAsyncWithHttpInfo
     *
     * User mention timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdMentionsAsyncWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2UsersIdMentionsResponse';
        $request = $this->usersIdMentionsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdMentions'
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdMentionsRequest($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdMentions'
            );
        }
        if (!preg_match("/^[0-9]{1,19}\\z/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.usersIdMentions, must conform to the pattern /^[0-9]{1,19}\\z/.");
        }

        if ($since_id !== null && !preg_match("/^[0-9]{1,19}$/", $since_id)) {
            throw new \InvalidArgumentException("invalid value for \"since_id\" when calling TweetsApi.usersIdMentions, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($until_id !== null && !preg_match("/^[0-9]{1,19}$/", $until_id)) {
            throw new \InvalidArgumentException("invalid value for \"until_id\" when calling TweetsApi.usersIdMentions, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdMentions, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 5) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdMentions, must be bigger than or equal to 5.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.usersIdMentions, must be bigger than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.usersIdMentions, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.usersIdMentions, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.usersIdMentions, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.usersIdMentions, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.usersIdMentions, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.usersIdMentions, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/users/{id}/mentions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $until_id,
            'until_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'start_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'end_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdRetweets
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersRetweetsCreateRequest $users_retweets_create_request users_retweets_create_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UsersRetweetsCreateResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdRetweets($id, $users_retweets_create_request = null)
    {
        list($response) = $this->usersIdRetweetsWithHttpInfo($id, $users_retweets_create_request);
        return $response;
    }

    /**
     * Operation usersIdRetweetsWithHttpInfo
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersRetweetsCreateRequest $users_retweets_create_request (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UsersRetweetsCreateResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdRetweetsWithHttpInfo($id, $users_retweets_create_request = null)
    {
        $request = $this->usersIdRetweetsRequest($id, $users_retweets_create_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UsersRetweetsCreateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UsersRetweetsCreateResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UsersRetweetsCreateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\UsersRetweetsCreateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UsersRetweetsCreateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdRetweetsAsync
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersRetweetsCreateRequest $users_retweets_create_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdRetweetsAsync($id, $users_retweets_create_request = null)
    {
        return $this->usersIdRetweetsAsyncWithHttpInfo($id, $users_retweets_create_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdRetweetsAsyncWithHttpInfo
     *
     * Causes the User (in the path) to retweet the specified Tweet.
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersRetweetsCreateRequest $users_retweets_create_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdRetweetsAsyncWithHttpInfo($id, $users_retweets_create_request = null)
    {
        $returnType = '\OpenAPI\Client\Model\UsersRetweetsCreateResponse';
        $request = $this->usersIdRetweetsRequest($id, $users_retweets_create_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdRetweets'
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  \OpenAPI\Client\Model\UsersRetweetsCreateRequest $users_retweets_create_request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdRetweetsRequest($id, $users_retweets_create_request = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdRetweets'
            );
        }

        $resourcePath = '/2/users/{id}/retweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($users_retweets_create_request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($users_retweets_create_request));
            } else {
                $httpBody = $users_retweets_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdTimeline
     *
     * User home timeline by User ID
     *
     * @param  string $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdTimeline($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdTimelineWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdTimelineWithHttpInfo
     *
     * User home timeline by User ID
     *
     * @param  string $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdTimelineWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->usersIdTimelineRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdTimelineAsync
     *
     * User home timeline by User ID
     *
     * @param  string $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTimelineAsync($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdTimelineAsyncWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdTimelineAsyncWithHttpInfo
     *
     * User home timeline by User ID
     *
     * @param  string $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTimelineAsyncWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2UsersIdTimelinesReverseChronologicalResponse';
        $request = $this->usersIdTimelineRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdTimeline'
     *
     * @param  string $id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdTimelineRequest($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdTimeline'
            );
        }
        if ($since_id !== null && !preg_match("/^[0-9]{1,19}$/", $since_id)) {
            throw new \InvalidArgumentException("invalid value for \"since_id\" when calling TweetsApi.usersIdTimeline, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($until_id !== null && !preg_match("/^[0-9]{1,19}$/", $until_id)) {
            throw new \InvalidArgumentException("invalid value for \"until_id\" when calling TweetsApi.usersIdTimeline, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdTimeline, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdTimeline, must be bigger than or equal to 1.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.usersIdTimeline, must be bigger than or equal to 1.');
        }


        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.usersIdTimeline, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.usersIdTimeline, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.usersIdTimeline, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.usersIdTimeline, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.usersIdTimeline, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.usersIdTimeline, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/users/{id}/timelines/reverse_chronological';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $until_id,
            'until_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'start_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'end_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdTweets
     *
     * User Tweets timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Get2UsersIdTweetsResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdTweets($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        list($response) = $this->usersIdTweetsWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);
        return $response;
    }

    /**
     * Operation usersIdTweetsWithHttpInfo
     *
     * User Tweets timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Get2UsersIdTweetsResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdTweetsWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $request = $this->usersIdTweetsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Get2UsersIdTweetsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Get2UsersIdTweetsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Get2UsersIdTweetsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Get2UsersIdTweetsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Get2UsersIdTweetsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdTweetsAsync
     *
     * User Tweets timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTweetsAsync($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        return $this->usersIdTweetsAsyncWithHttpInfo($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdTweetsAsyncWithHttpInfo
     *
     * User Tweets timeline by User ID
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTweetsAsyncWithHttpInfo($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        $returnType = '\OpenAPI\Client\Model\Get2UsersIdTweetsResponse';
        $request = $this->usersIdTweetsRequest($id, $since_id, $until_id, $max_results, $pagination_token, $exclude, $start_time, $end_time, $tweet_fields, $expansions, $media_fields, $poll_fields, $user_fields, $place_fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdTweets'
     *
     * @param  string $id The ID of the User to lookup. (required)
     * @param  string $since_id The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified. (optional)
     * @param  string $until_id The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified. (optional)
     * @param  int $max_results The maximum number of results. (optional)
     * @param  string $pagination_token This parameter is used to get the next &#39;page&#39; of results. (optional)
     * @param  string[] $exclude The set of entities to exclude (e.g. &#39;replies&#39; or &#39;retweets&#39;). (optional)
     * @param  \DateTime $start_time YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified. (optional)
     * @param  \DateTime $end_time YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified. (optional)
     * @param  string[] $tweet_fields A comma separated list of Tweet fields to display. (optional)
     * @param  string[] $expansions A comma separated list of fields to expand. (optional)
     * @param  string[] $media_fields A comma separated list of Media fields to display. (optional)
     * @param  string[] $poll_fields A comma separated list of Poll fields to display. (optional)
     * @param  string[] $user_fields A comma separated list of User fields to display. (optional)
     * @param  string[] $place_fields A comma separated list of Place fields to display. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdTweetsRequest($id, $since_id = null, $until_id = null, $max_results = null, $pagination_token = null, $exclude = null, $start_time = null, $end_time = null, $tweet_fields = null, $expansions = null, $media_fields = null, $poll_fields = null, $user_fields = null, $place_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdTweets'
            );
        }
        if (!preg_match("/^[0-9]{1,19}\\z/", $id)) {
            throw new \InvalidArgumentException("invalid value for \"id\" when calling TweetsApi.usersIdTweets, must conform to the pattern /^[0-9]{1,19}\\z/.");
        }

        if ($since_id !== null && !preg_match("/^[0-9]{1,19}$/", $since_id)) {
            throw new \InvalidArgumentException("invalid value for \"since_id\" when calling TweetsApi.usersIdTweets, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($until_id !== null && !preg_match("/^[0-9]{1,19}$/", $until_id)) {
            throw new \InvalidArgumentException("invalid value for \"until_id\" when calling TweetsApi.usersIdTweets, must conform to the pattern /^[0-9]{1,19}$/.");
        }

        if ($max_results !== null && $max_results > 100) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdTweets, must be smaller than or equal to 100.');
        }
        if ($max_results !== null && $max_results < 5) {
            throw new \InvalidArgumentException('invalid value for "$max_results" when calling TweetsApi.usersIdTweets, must be bigger than or equal to 5.');
        }

        if ($pagination_token !== null && strlen($pagination_token) < 1) {
            throw new \InvalidArgumentException('invalid length for "$pagination_token" when calling TweetsApi.usersIdTweets, must be bigger than or equal to 1.');
        }

        if ($exclude !== null && count($exclude) < 1) {
            throw new \InvalidArgumentException('invalid value for "$exclude" when calling TweetsApi.usersIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($tweet_fields !== null && count($tweet_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$tweet_fields" when calling TweetsApi.usersIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($expansions !== null && count($expansions) < 1) {
            throw new \InvalidArgumentException('invalid value for "$expansions" when calling TweetsApi.usersIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($media_fields !== null && count($media_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$media_fields" when calling TweetsApi.usersIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($poll_fields !== null && count($poll_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$poll_fields" when calling TweetsApi.usersIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($user_fields !== null && count($user_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$user_fields" when calling TweetsApi.usersIdTweets, number of items must be greater than or equal to 1.');
        }

        if ($place_fields !== null && count($place_fields) < 1) {
            throw new \InvalidArgumentException('invalid value for "$place_fields" when calling TweetsApi.usersIdTweets, number of items must be greater than or equal to 1.');
        }


        $resourcePath = '/2/users/{id}/tweets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since_id,
            'since_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $until_id,
            'until_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_results,
            'max_results', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pagination_token,
            'pagination_token', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude,
            'exclude', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_time,
            'start_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_time,
            'end_time', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tweet_fields,
            'tweet.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expansions,
            'expansions', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $media_fields,
            'media.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $poll_fields,
            'poll.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_fields,
            'user.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $place_fields,
            'place.fields', // param base name
            'array', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdUnlike
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  string $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UsersLikesDeleteResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdUnlike($id, $tweet_id)
    {
        list($response) = $this->usersIdUnlikeWithHttpInfo($id, $tweet_id);
        return $response;
    }

    /**
     * Operation usersIdUnlikeWithHttpInfo
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  string $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UsersLikesDeleteResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdUnlikeWithHttpInfo($id, $tweet_id)
    {
        $request = $this->usersIdUnlikeRequest($id, $tweet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UsersLikesDeleteResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UsersLikesDeleteResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UsersLikesDeleteResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\UsersLikesDeleteResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UsersLikesDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdUnlikeAsync
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  string $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnlikeAsync($id, $tweet_id)
    {
        return $this->usersIdUnlikeAsyncWithHttpInfo($id, $tweet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdUnlikeAsyncWithHttpInfo
     *
     * Causes the User (in the path) to unlike the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  string $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnlikeAsyncWithHttpInfo($id, $tweet_id)
    {
        $returnType = '\OpenAPI\Client\Model\UsersLikesDeleteResponse';
        $request = $this->usersIdUnlikeRequest($id, $tweet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdUnlike'
     *
     * @param  string $id The ID of the authenticated source User that is requesting to unlike the Tweet. (required)
     * @param  string $tweet_id The ID of the Tweet that the User is requesting to unlike. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdUnlikeRequest($id, $tweet_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdUnlike'
            );
        }
        // verify the required parameter 'tweet_id' is set
        if ($tweet_id === null || (is_array($tweet_id) && count($tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tweet_id when calling usersIdUnlike'
            );
        }
        if (!preg_match("/^[0-9]{1,19}$/", $tweet_id)) {
            throw new \InvalidArgumentException("invalid value for \"tweet_id\" when calling TweetsApi.usersIdUnlike, must conform to the pattern /^[0-9]{1,19}$/.");
        }


        $resourcePath = '/2/users/{id}/likes/{tweet_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($tweet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tweet_id' . '}',
                ObjectSerializer::toPathValue($tweet_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdUnretweets
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  string $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UsersRetweetsDeleteResponse|\OpenAPI\Client\Model\Error
     */
    public function usersIdUnretweets($id, $source_tweet_id)
    {
        list($response) = $this->usersIdUnretweetsWithHttpInfo($id, $source_tweet_id);
        return $response;
    }

    /**
     * Operation usersIdUnretweetsWithHttpInfo
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  string $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UsersRetweetsDeleteResponse|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdUnretweetsWithHttpInfo($id, $source_tweet_id)
    {
        $request = $this->usersIdUnretweetsRequest($id, $source_tweet_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UsersRetweetsDeleteResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UsersRetweetsDeleteResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UsersRetweetsDeleteResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\UsersRetweetsDeleteResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UsersRetweetsDeleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdUnretweetsAsync
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  string $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnretweetsAsync($id, $source_tweet_id)
    {
        return $this->usersIdUnretweetsAsyncWithHttpInfo($id, $source_tweet_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdUnretweetsAsyncWithHttpInfo
     *
     * Causes the User (in the path) to unretweet the specified Tweet
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  string $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdUnretweetsAsyncWithHttpInfo($id, $source_tweet_id)
    {
        $returnType = '\OpenAPI\Client\Model\UsersRetweetsDeleteResponse';
        $request = $this->usersIdUnretweetsRequest($id, $source_tweet_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdUnretweets'
     *
     * @param  string $id The ID of the authenticated source User that is requesting to retweet the Tweet. (required)
     * @param  string $source_tweet_id The ID of the Tweet that the User is requesting to unretweet. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdUnretweetsRequest($id, $source_tweet_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdUnretweets'
            );
        }
        // verify the required parameter 'source_tweet_id' is set
        if ($source_tweet_id === null || (is_array($source_tweet_id) && count($source_tweet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $source_tweet_id when calling usersIdUnretweets'
            );
        }
        if (!preg_match("/^[0-9]{1,19}$/", $source_tweet_id)) {
            throw new \InvalidArgumentException("invalid value for \"source_tweet_id\" when calling TweetsApi.usersIdUnretweets, must conform to the pattern /^[0-9]{1,19}$/.");
        }


        $resourcePath = '/2/users/{id}/retweets/{source_tweet_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($source_tweet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'source_tweet_id' . '}',
                ObjectSerializer::toPathValue($source_tweet_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
